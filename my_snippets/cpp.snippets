snippet beg "begin"
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#pragma GCC optimization("unroll-loops")
#pragma GCC optimize("fast-math")
#pragma GCC optimize("no-stack-protector")

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;

#define all(a) a.begin(), a.end()
#define REP(i, a, b) for (ll i = a; i < b; i++)
#define REPI(i, a, b) for (ll i = b - 1; i >= a; i--)
#define each(a, b) for (auto &a : b)
#define amax(a, b) a = max(a, b)
#define amin(a, b) a = min(a, b)
#define ff first
#define ss second
#define pb push_back
#define sz(x) (int)(x).size()
#define mp make_pair
#define mt make_tuple
#define lc(x) (x << 1)
#define rc(x) ((x << 1) | 1)
#define setbits(x) __builtin_popcountll(x)
#define mod 1000000007
#define inf 1e18
#define ps(x, y) fixed << setprecision(y) << x
#define mk(arr, n, type) type *arr = new type[n];
#define range(a, b) substr(a, b - a + 1)
#define w(x)  \
    int x;    \
    cin >> x; \
    while (x--)
#define FIO                       \
    ios_base::sync_with_stdio(0); \
    cin.tie(0);                   \
    cout.tie(0)
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#define epsilon 1e-9
#define sign(x) (x > 0) - (x < 0)
#define is_poweroftwo(n) (n && !(n & (n - 1)))
template <class Ty, std::size_t N>
using ar = array<Ty, N>;
using pii = pair<int, int>;
using vi = vector<int>;
using vb = vector<bool>;
using vvi = vector<vi>;
using mii = map<int, int>;
using pqb = priority_queue<int>;
using pqs = priority_queue<int, vi, greater<int>>;
using ll = long long;
using ull = unsigned long long;
using ld = long double;
template <typename T>
#define ordered_set(T) = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
void nothing();

template <class T1, class T2>
ostream &operator<<(ostream &os, const pair<T1, T2> &p)
{
    os << '{' << p.first << ", " << p.second << '}';
    return os;
}

template <typename C,
          typename T = std::decay_t<decltype(*begin(std::declval<C>()))>,
          typename std::enable_if<!std::is_same<C, std::string>::value>::type * = nullptr>
ostream &operator<<(ostream &os, const C &container)
{
    bool first = true;
    stringstream ss;
    ss << '[';
    for (const auto &x : container)
    {
        if (!first)
        {
            ss << ", ";
        }
        first = false;
        ss << x;
    }
    ss << ']';
    return os << ss.str();
}

inline namespace Stringify
{
    string to_string(int x) { return std::to_string(x); }
    string to_string(ll x) { return std::to_string(x); }
    string to_string(float x) { return std::to_string(x); }
    string to_string(double x) { return std::to_string(x); }
    string to_string(char c) { return string(1, c); }
    string to_string(bool b) { return b ? "true" : "false"; }
    string to_string(const char *s) { return string(s); }
    string to_string(string s) { return s; }
    string to_string(vb v)
    {
        string res;
        for (int i = 0; i < sz(v); i++)
            res += char('0' + v[i]);
        return res;
    }
    template <size_t S>
    string to_string(bitset<S> b)
    {
        string res;
        for (int i = 0; i < sz(b); i++)
            res += char('0' + b[i]);
        return res;
    }
    template <class H, class T>
    string to_string(pair<H, T> v) { return Stringify::to_string(v.ff) + " " + Stringify::to_string(v.ss); }
    template <class T>
    string to_string(T v)
    {
        bool f = 1;
        string res;
        each(x, v)
        {
            if (!f)
                res += ' ';
            f = 0;
            res += Stringify::to_string(x);
        }
        return res;
    }
    template <class H, class T>
    string to_string(unordered_map<H, T> v)
    {
        bool f = 1;
        string res;
        each(x, v)
        {
            if (!f)
                res += ',';
            f = 0;
            res += " (" + Stringify::to_string(x.ff) + "->" + Stringify::to_string(x.ss) + ")";
        }
        return res;
    }
    template <class H, class T>
    string to_string(map<H, T> v)
    {
        bool f = 1;
        string res;
        each(x, v)
        {
            if (!f)
                res += ',';
            f = 0;
            res += "(" + Stringify::to_string(x.ff) + "->" + Stringify::to_string(x.ss) + ")";
        }
        return res;
    }
}
inline namespace IO
{
    template <class A>
    void read(vector<A> &v);
    template <class A, size_t S>
    void read(ar<A, S> &a);
    template <class T>
    void read(T &x) { cin >> x; }
    void read(double &d)
    {
        string t;
        read(t);
        d = stod(t);
    }
    void read(long double &d)
    {
        string t;
        read(t);
        d = stold(t);
    }
    template <class H, class... T>
    void read(H &h, T &...t)
    {
        read(h);
        read(t...);
    }
    template <class A>
    void read(vector<A> &x) { each(a, x) read(a); }
    template <class A, size_t S>
    void read(array<A, S> &x) { each(a, x) read(a); }
    template <class A>
    void write(A x) { cout << Stringify::to_string(x); }
    template <class H, class... T>
    void write(const H &h, const T &...t)
    {
        write(h);
        write(t...);
    }
    void print() { write("\n"); }
    template <class H, class... T>
    void print(const H &h, const T &...t)
    {
        write(h);
        if (sizeof...(t))
            write(' ');
        print(t...);
    }
}
#define debugging
#ifdef debugging
#define debug(...)                                                \
    std::cerr << "\e[91m" << __func__ << ":" << __LINE__ << "\t"; \
    __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char *name, Arg1 &&arg1)
{
    std::cerr << name << " : " << arg1 << "\e[39m" << '\n';
}
template <typename Arg1, typename... Args>
void __f(const char *names, Arg1 &&arg1, Args &&...args)
{
    const char *comma = strchr(names + 1, ',');
    std::cerr.write(names, comma - names) << " : " << arg1 << " | ";
    __f(comma + 1, args...);
}
#else
#define debug(...) ;
#endif
long long binpow(long long a, long long b)
{
    long long res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}
long long binpow(long long a, long long b, long long m)
{
    a %= m;
    long long res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
// Miller-Rabin Primality test
bool isprime(ll n)
{
    if (n < 2)
        return false;
    for (ll x : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37})
    {
        if (n == x)
            return true;
        bool flag = true;
        ll r = 1;
        ll t = 1;
        while (r <= ((n - 1) >> __builtin_ctzll(n - 1)))
        {
            if (r & ((n - 1) >> __builtin_ctzll(n - 1)))
                t = ((__int128)t * x) % n;
            x = ((__int128)x * x) % n;
            r <<= 1;
        }
        if (t == 1 || t == n - 1)
            flag = false;
        for (r = 0; r < __builtin_ctzll(n - 1); r++)
        {
            t = ((__int128)t * t) % n;
            if (t == n - 1)
                flag = false;
        }
        if (flag)
            return false;
    }
    return true;
}
// overflow error is possible
int leftbit(long long n)
{

    (((((n |= n >> 1) |= n >> 2) |= n >> 4) |= n >> 8) |= n >> 16);
    // n |= n >> 1;
    //  n |= n >> 2;
    //  n |= n >> 4;
    //  n |= n >> 8;
    //  n |= n >> 16;
    n = n + 1;
    // return the nearest power of 2
    // return (n >> 1);
    // return the left bit
    return (log2(n >> 1));
}
// ultall takes a number and toggles all bits till the Most significant bit (MSB)
// and return this number
int ultall(unsigned long long n)
{

    int max = leftbit(n);
    for (int i = 0; i <= max; i++)
    {
        n ^= (1 << i);
    }
    return n;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
void calc() {}
signed main()
{
#ifndef ONLINE_JUDGE
#ifndef CPH
    auto t1 = std::chrono::high_resolution_clock::now();
#endif
#endif
    FIO;
    w(T)
    {
        ${0:calc();}
    }
#ifndef ONLINE_JUDGE
#ifndef CPH
    auto t2 = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count();
    cerr << duration;
#endif
#endif
    return 0;
}
endsnippet

snippet segtree "Segment Tree"
/* 
    Segment tree supporting point updates and range queries 
    source array (a) is 0 indexed 
    segment tree (t) is 1 indexed 
*/
struct SegmentTree
{
    long n; // size of source array a
    // t is the segment tree
    vector<int> a, t;

    void init(int x)
    {
        n = x;
        t.assign(4 * n, 0);
    }

    void init(long x, vector<int> y)
    {
        n = x;
        a = move(y);
        t.resize(4 * n);
        build(1, 0, n - 1);
    }

    long merge(long x, long y) { return x + y; }

    long upd(long x, long y) { return y; }

    void build(int i, long l, long r)
    {

        if (l == r)
        {
            t[i] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(lc(i), l, mid);
        build(rc(i), mid + 1, r);
        t[i] = merge(t[lc(i)], t[rc(i)]);
    }

    void modify(int i, long l, long r, long pos, long val) //point update
    {
        if (l == r)
        {
            t[i] = upd(t[i], val);
            return;
        }
        long mid = (l + r) >> 1;
        if (pos <= mid)
            modify(lc(i), l, mid, pos, val);
        else
            modify(rc(i), mid + 1, r, pos, val);
        t[i] = merge(t[lc(i)], t[rc(i)]);
    }

    // query in the range [ql,qr] both inclusive
    long query(int i, long l, long r, long ql, long qr)
    {
        if (l > qr || r < ql)
            return 0;
        if (l >= ql && r <= qr)
            return t[i];
        int mid = (l + r) >> 1;
        return merge(query(lc(i), l, mid, ql, qr), query(rc(i), mid + 1, r, ql, qr));
    }

    void modify(long pos, long val) { modify(1, 0, n - 1, pos, val); }

    long query(long l, long r) { return query(1, 0, n - 1, l, r); }
} ST;
endsnippet

snippet segtreeL " Segment Tree with lazy propagation"
struct SegmentTree
{
    int n;
    vector<int> a, t, lazy;

    void init(int x)
    {
        n = x;
        t.assign(4 * n, 0);
        lazy.assign(4 * n, 0);
    }

    void init(int x, vector<int> y)
    {
        n = x;
        a = y;
        t.resize(4 * n);
        lazy.assign(4 * n, 0);
        build(1, 0, n - 1);
    }

    int merge(int x, int y) { return x + y; }

    int upd(int x, int y) { return x + y; }

    void build(int i, int l, int r)
    {
        if (l == r)
        {
            t[i] = a[l];
            return;
        }
        int mid = (l + r) / 2;
        build(lc(i), l, mid);
        build(rc(i), mid + 1, r);
        t[i] = merge(t[lc(i)], t[rc(i)]);
    }

    void push(int i, int l, int r) // i-> tree index , l-> left bound, r-> right bound for range updates
    {
        t[i] = upd(t[i], (lazy[i] * (r - l + 1)));
        if (l != r)
        {
            lazy[lc(i)] = upd(lazy[lc(i)], lazy[i]);
            lazy[rc(i)] = upd(lazy[rc(i)], lazy[i]);
        }
        lazy[i] = 0;
    }
    // call modify not push
    void modify(int i, int l, int r, int ql, int qr, int val)
    {
        if (l > qr || r < ql)
            return;
        if (lazy[i] != 0)
            push(i, l, r);
        if (l >= ql && r <= qr)
        {
            lazy[i] = upd(lazy[i], val);
            push(i, l, r);
            return;
        }
        int mid = (l + r) / 2;
        modify(lc(i), l, mid, ql, qr, val);
        modify(rc(i), mid + 1, r, ql, qr, val);
        t[i] = merge(t[lc(i)], t[rc(i)]);
    }

    int query(int i, int l, int r, int ql, int qr)
    {
        if (l > qr || r < ql)
            return 0;
        if (lazy[i] != 0)
            push(i, l, r);
        if (l >= ql && r <= qr)
            return t[i];
        int mid = (l + r) / 2;
        int resL = query(lc(i), l, mid, ql, qr);
        int resR = query(rc(i), mid + 1, r, ql, qr);
        return merge(resL, resR);
    }

    void modify(int l, int r, int val) { modify(1, 0, n - 1, l, r, val); }

    void modify(int pos, int val) { modify(1, 0, n - 1, pos, pos, val); }

    int query(int l, int r) { return query(1, 0, n - 1, l, r); }

    int query(int pos) { return query(1, 0, n - 1, pos, pos); }
} ST;
endsnippet

snippet strhash "String Hashing using only one mod  "
// String Hashing with only one mod


 

const int N = 1e6 + 6;
const int mod = 1e9 + 7;
const int base = 33;
 
int add(int a, int b, int mod){
    int res = (a + b) % mod;
    if(res < 0)
        res += mod;
    return res;
}
 
int mult(int a, int b, int mod){
    int res = (a * 1LL * b) % mod;
    if(res < 0)
        res += mod;
    return res;
}
 
int power(int a, int b, int mod){
    int res = 1;
    while(b){
        if((b % 2) == 1)
            res = mult(res, a, mod);
        a = mult(a, a, mod);
        b /= 2;
    }
    return res;
}
 
int pw[N];
int inv[N];
int H[N];
 
void precalc() {
    pw[0] = 1;
    for(int i = 1; i < N; i++)
        pw[i] = mult(pw[i - 1], base, mod);
    
    int pw_inv = power(base , mod - 2 , mod);
    inv[0] = 1;
    for(int i = 1; i < N; i++)
        inv[i] = mult(inv[i - 1], pw_inv, mod);
}
 
void build(string s){
    int n = s.length();
    for(int i = 0; i < n ; ++i){
        H[i] = add((i == 0) ? 0 : H[i - 1], mult(pw[i], s[i] - 'a' + 1, mod), mod);
    }
}
 
int getHash(int x , int y){
    int res = add(H[y], (x == 0) ? 0 : -H[x - 1], mod);
    res = mult(res , (x == 0) ? 1 : inv[x], mod);
    return res;
}
 
/*
Example and how to use 
int main() {
    precalc();
    string s = "ABCDEFGABCDEFGH";
    build(s);
    cout<< getHash(2, 5) << " == " << getHash(9, 12) << endl;
}*/
endsnippet

snippet printarr "print arrays"
void print(vi a, int l, int u)
{
    for (int i = 0; i < u; i++)
    {
        cout << a[i] << " ";
    }
    cout << "\n";
}
void print(vi a)
{

    print(a, 0, a.size());
}
void printl(vi a, int l)
{
    print(a, l, a.size());
}
void printu(vi a, int u)
{
    print(a, 0, u);
}
endsnippet

snippet 128IO "input and output suport of int128 "

template <class integer>
inline integer to_int(const string &s, size_t *idx = 0, int base = 10)
{
    size_t n = s.size(), i = idx ? *idx : 0;
    bool sign = false;
    integer x = 0;
    if (s[i] == '-')
        ++i, sign = true;
    function<int(char)> char_to_digit = [&](char c) {
     static const int d[] = {'a'-10,'0'}; 
      return tolower(c)-d[isdigit(c)]; };
    while (i < n)
        x *= base, x += char_to_digit(s[i++]);
    if (idx)
        *idx = i;
    return sign ? -x : x;
}

template <class integer>
inline string to_string(integer x, int base = 10)
{
    bool sign = false;
    string s;
    if (x < 0)
        x = -x, sign = true;
    function<char(int)> digit_to_char = [](int d) {
	static const char c[] = {'a'-10,'0'};
	return c[d < 10]+d; };
    do
        s += digit_to_char(x % base), x /= base;
    while (x > 0);
    if (sign)
        s += '-';
    reverse(s.begin(), s.end());
    return s;
}

template <class integer>
inline istream &read(istream &is, integer &x)
{
    string s;
    is >> s, x = to_int<integer>(s);
    return is;
}

template <class integer>
inline ostream &write(ostream &os, integer x) { return os << to_string(x); }

using lll = signed __int128;
using ulll = unsigned __int128;

inline istream &operator>>(istream &is, lll &x) { return read(is, x); }
inline istream &operator>>(istream &is, ulll &x) { return read(is, x); }
inline ostream &operator<<(ostream &os, lll x) { return write(os, x); }
inline ostream &operator<<(ostream &os, ulll x) { return write(os, x); }
endsnippet

snippet dsu "Disjoint Set union/Union find with 1 based indexing and union by size along with path compression"

class union_find
{
    int n;
    vector<int> par;
    vector<int> sz;

public:
    // constructor to intialize the par and sz;
    union_find(int nval)
    {
        n = nval;
        par.resize(n + 1);
        sz.resize(n + 1);

        for (int i = 1; i <= n; ++i)
            par[i] = i, sz[i] = 1;
    }
    union_find(vector<int> &p)
    {
        par = p;
        n = par.size() + 1;
    }
    union_find(vector<int> &p, vector<int> &r)
    {
        par = p;
        n = par.size() + 1;
        sz = r;
    }

    //O(1) ammortized
    int root(int a)
    {
        // if (x == par[x])
        //     return x;

        // return par[x] = root(par[x]);
        return (par[a] = (par[a] == a ? a : root(par[a])));
    }

    //O(1) ammortized
    bool find(int a, int b)
    {
        return root(a) == root(b);
    }

    //O(1) ammortized
    int un(int a, int b)
    {
        int ra = root(a);
        int rb = root(b);

        if (ra == rb)
            return 0;

        if (sz[ra] > sz[rb])
            swap(ra, rb);

        par[ra] = rb;
        sz[rb] += sz[ra];
        return 1;
    }
~union_find()
{
	delete[] pr, delete[] sz;
}
    // 1 based indexing by default
};
endsnippet

snippet Bigmul "Big_Multiplication"

// caluclates S1 *S2
// the ans array stores the answer in reverse format,i.e ans[0]=units digit ans[1]=ten's digit.
// O(5*N) time for each multiplication
// a string containing the answer in proper format is returned
string multiply(string s1, string s2)
{

    int a[(int)(1e5)], b[(int)(1e5)];
    int l1 = s1.length();
    int l2 = s2.size();
    int i, j, tmp;
    int ans[(int)2e5] = {0};
    for (i = l1 - 1, j = 0; i >= 0; i--, j++)
    {
        a[j] = s1[i] - '0';
    }
    for (i = l2 - 1, j = 0; i >= 0; i--, j++)
    {
        b[j] = s2[i] - '0';
    }
    for (i = 0; i < l2; i++)
    {
        for (j = 0; j < l1; j++)
        {
            ans[i + j] += b[i] * a[j];
        }
    }
    for (i = 0; i < l1 + l2; i++)
    {
        tmp = ans[i] / 10;
        ans[i] = ans[i] % 10;
        ans[i + 1] = ans[i + 1] + tmp;
    }
    for (i = l1 + l2; i >= 0; i--)
    {
        if (ans[i] > 0)
            break;
    }
    string s3;
    for (; i >= 0; i--)
    {
        //printf("%d", ans[i]);
        s3 += (ans[i] + '0');
    }
    return s3;
}
endsnippet

snippet IntTrie "Trie for inserting integers Bitwise"
 class Node
    {

    public:
        Node *children[2] = {};
        bool end;

        // cnt variable at each node is keeping a count of integers
        // which passes through that node while inserting the integer
        // into trie.An integer is being added into this trie based
        // on its bit representation.So, lets say the bit representation
        // at a node from root of the trie to that node is 101(I.e.node is at level 3),
        // so cnt at this node will give the no of integers which have prefix bit
        // representation as 101 like the nos with bit representation
        // 10101...., 10111......, 1010000.... Etc.

        int cnt;
        Node()
        {
            end = 0, cnt = 0;
        }
    };
    class Trie
    {
        Node *root;
        int bits;

    public:
        Trie()
        {
            root = new Node();
            bits = 31;
        }
        Trie(vector<int> &a)
        {
            root = new Node();
            insert(a);
        }
        Trie(vector<int> &a, int bits)
        {
            this->bits = bits;
            root = new Node();
            insert(a);
        }
        void set_no_bits(int a)
        {
            bits = a;
        }
        void insert(int &x)
        {
            Node *cur = root;
            for (int i = bits; i >= 0; i--)
            {
                bool b = (x >> i) & 1;
                if (!cur->children[b])
                {
                    cur->children[b] = new Node();
                }
                cur = cur->children[b];
                cur->cnt++;
            }
            cur->end = true;
        }
        void insert(vector<int> &a)
        {
            for (auto s : a)
                insert(s);
        }
        void remove(int &x)
        {
            Node *cur = root;
            for (int i = bits; i >= 0; i--)
            {
                bool b = (x >> i) & 1;
                cur = cur->children[b];
                cur->cnt--;
            }
            cur->end = false;
        }
        void remove(vector<int> &s)
        {
            for (auto &x : s)
                remove(x);
        }
        bool found(int &s)
        {
            Node *cur = root;
            for (int i = bits; i >= 0; i--)
            {
                bool b = (s >> i) & 1;
                if (!cur->children[b])
                    return 0;
                cur = cur->children[b];
            }
            return cur->end;
        }
        int maxxor(int x)
        {
            Node *cur = root;
            unsigned int ans = 0;
            for (int i = bits; i >= 0; i--)
            {
                bool b = (x >> i) & 1;
                if (cur->children[!b] and cur->children[!b]->cnt > 0)
                {
                    ans += (1LL << i);
                    cur = cur->children[!b];
                }
                else
                    cur = cur->children[b];
            }
            return ans;
        }
        int maxxor(vector<int> &s)
        {
            int ans = -1;
            for (auto x : s)
                ans = max(ans, maxxor(x));

            return ans;
        }
    };
endsnippet

snippet StrTrie "Trie for inserting strings character-wise"
 class Node
    {

    public:
        Node *children[26] = {};
        // end tells us that whether at this node a string has been completed or not
        bool end;

        //cnt variable at each node is keeping a count of
        //strings which passes through that node while
        //inserting the string into trie.

        //A string is being added into this trie character by character
        //So, lets say the character representation at a node from
        //root of the trie to that node is abc (I.e.node is at level 3),
        //so cnt at this node will give the no of strings which have
        //prefix charcters representation as abc like the nos with
        //charcters representation abcdef...., abcff......, abceeghx.... Etc.

        int cnt;
        Node()
        {
            end = 0, cnt = 0;
        }
    };
    class Trie
    {
        Node *root;

    public:
        Trie()
        {
            root = new Node();
        }
        Trie(vector<string> &a)
        {
            root = new Node();
            insert(a);
        }
        void insert(string &s)
        {
            Node *cur = root;
            for (char &c : s)
            {
                if (!cur->children[c - 'a'])
                {
                    cur->children[c - 'a'] = new Node();
                }
                cur = cur->children[c - 'a'];
                cur->cnt++;
            }
            cur->end = true;
        }
        void insert(vector<string> &a)
        {
            for (string s : a)
                insert(s);
        }
        void remove(string &x)
        {
            Node *cur = root;
            for (char &c : x)
            {
                cur = cur->children[c - 'a'];
                cur->cnt--;
            }
            cur->end = false;
        }
        void remove(vector<string> &s)
        {
            for (auto &x : s)
                remove(x);
        }
        bool found(string &s)
        {
            Node *cur = root;
            for (char c : s)
            {
                if (!cur->children[c - 'a'])
                    return 0;
                cur = cur->children[c - 'a'];
            }
            return cur->end;
        }
    };
endsnippet

snippet FenTree "Fenwick Tree supporting range updates and range queries"
#define sz(x) (int)(x).size()

// Range updates and point queries;
// to update a range [a,b] with +x; do update(a,x) and update(1+b,-x);
// to query a range [0,a] do ft.query(a+1);
struct FT
{
    vector<ll> s;
    FT(int n) : s(n) {}
    void update(int pos, ll dif)
    {
        // a[pos] += dif
        for (; pos < sz(s); pos |= pos + 1)
            s[pos] += dif;
    }
    // returns sum of values in [0, pos)
    ll query(int pos)
    {

        ll res = 0;
        for (; pos > 0; pos &= pos - 1)
            res += s[pos - 1];
        return res;
    }
};
endsnippet

snippet CentDecomp "Centroid Decomposition"

const int N = 1e5 + 10;
const int LOGN = 20;
// Original Tree
vector<int> g[N];
int sub[N], nn, U[N], V[N], W[N], deleted[N];
// Centroid Tree
int par[N], level[N], dist[LOGN][N];
// dist[LOGN][N] : dist[lvl][x] :  Distance between C and x in the original tree, when node C becomes a centroid at level "lvl".
// G[u] --> [v1, v2, v3] ... Not doing this.
// G[u] --> [e1, e1, e3 ..]
int adj(int x, int e) { return U[e] ^ V[e] ^ x; }
void dfs1(int u, int p)
{
    sub[u] = 1;
    nn++;
    for (auto e : g[u])
    {
        int w = adj(u, e);
        if (w != p && !deleted[e])
            dfs1(w, u), sub[u] += sub[w];
    }
}
int find_centroid(int u, int p)
{
    for (auto e : g[u])
    {
        if (deleted[e])
            continue;
        int w = adj(u, e);
        if (w != p && sub[w] > nn / 2)
            return find_centroid(w, u);
    }
    return u;
}
void add_edge_centroid_tree(int parent, int child)
{
    par[child] = parent;
    level[child] = (parent != -1) ? level[parent] + 1 : 1;
}
void dfs2(int u, int p, int lvl)
{
    for (auto e : g[u])
    {
        int w = adj(u, e);
        if (w == p || deleted[e])
            continue;
        dist[lvl][w] = dist[lvl][u] + W[e];
        dfs2(w, u, lvl);
    }
}
// unordered_map<int, int> dist[N]; -- inefficient.
// all the nn nodes which lie in the component of "centroid"
// dist[centroid][x] = <value>
// int dist[LOGN][N]; (centroid,x) --> one to one mapping --> (level[centroid], x);
void decompose(int root, int p = -1)
{
    nn = 0;
    // Compute subtree sizes and no. of nodes (nn) in this tree.
    dfs1(root, root);
    // Find the centroid of the tree and make it the new root.
    int centroid = find_centroid(root, root);
    // Construct the Centroid Tree
    // if (p == -1)
    //     p = centroid;
    add_edge_centroid_tree(p, centroid);
    // Process the O(N) paths from centroid to all leaves in this component.
    dfs2(centroid, centroid, level[centroid]);
    // Delete the adjacent edges and recursively decompose the adjacent subtrees.
    for (auto e : g[centroid])
    {
        if (deleted[e])
            continue;
        deleted[e] = 1;
        int w = adj(centroid, e);
        decompose(w, centroid);
    }
}

int compute_distance(int x, int y)
{
    // We need to compute the LCA(x, y) in the centroid tree.
    // O(logN) by just manual iteration because
    // height of centroid tree is O(logN)

    // if binary jumping is used it becomes O(log(logN))
    int lca_level = 0;
    for (int i = x, j = y;
         (lca_level = level[i]) &&
         i != j;
         level[i] < level[j] ? (j = par[j]) : (i = par[i]))
        ;

    return dist[lca_level][x] + dist[lca_level][y];
}
endsnippet

snippet HLD "Heavy Light Decomposition supporting path updates and queries using segment tree with Lazy propagation"
// maximum number of nodes
const int N = 2e5 + 10;
// Log2(N)
const int LOGN = 20;

int U[N], V[N], W[N], baseArray[N], level[N], sub[N];
// stores the parent of the chain.
// For a heavy edge chainparent and chainhead will be the same.
// But for a light edge the chain parent will be the parent
// node and the chainhead will be the first node of the light chain
int chainParent[N];

// Stores the chainHead for each chain which is the first edge in that chain
int chainHead[N];

// buffer length. Used to find the maximum size of Basearray.
int blen = 1;

// Each chain is given a number.
// chainNo[i]--It stores the chain number for the ith node
int chainNo[N];

// stores the position in the linearized array for each node in the Tree.
int pos[N];

// the number of chains, both heavy and light in the tree
int nchain;

// U[i], V[i]-- represents a single edge i going from node U[i] to V[i]
//W[u]-- represents the node weight/value of the node j
vector<int> g[N];
// g[U[i]].push_back(i);
// g[V[i]].push_back(i);
/**
 * @brief finds the vertex on the opposite end of node x considering edge e
 * 
 * @param x a node/vertex in the edge list
 * @param e edge number
 * @return the opposite vertex 
 */
int adj(int x, int e)
{
    // returns node adjacent to x on the edge e.
    return x ^ U[e] ^ V[e];
}
// u is the node and ee is the edge which u came from
//  chainNo stores the which chain the node is part of
/**
 * @brief heavy light decomposition for an edge list graph
 * 
 * @param u current node 
 * @param ee parent edge ,i.e. edge number through which we came to u
 */
void HLD(int u, int ee)
{ // edge list graph.graph is 1-based.
    // uncomment the below line for edge weights in basearray
    // baseArray[blen] = W[ee];

    // this line is for node weights in basearray
    baseArray[blen] = W[u];
    pos[u] = blen;
    blen++;
    chainNo[u] = nchain;
    int sc = -1, mx = 0;
    for (auto e : g[u])
    {
        if (e == ee)
            continue;
        int w = adj(u, e);
        if (sub[w] > mx)
            sc = e, mx = sub[w];
    }
    if (sc == -1)
        return;
    HLD(adj(u, sc), sc);
    for (auto e : g[u])
    {
        if (e == ee || e == sc)
            continue;
        int w = adj(u, e);
        nchain++;
        chainParent[nchain] = u;
        chainHead[nchain] = w;
        HLD(w, e);
    }
}
vector<vi> parent;
vi out, in;
int tim = 0;
int l;

/**
 * @brief calulates the 2^j parent of each node in the tree. 
 * ALWAYS call parent_calc(root,root) 
 * otherwise it will mess up the parent array 
 * 
 * @param cur  current node
 * @param par parent node
 */
void parent_calc(int cur, int par)
{
    // int par;
    sub[cur] = 1;
    parent[cur][0] = par;
    level[cur] = level[par] + 1;
    in[cur] = (++tim);
    for (int i = 1; i <= l; i++)
    {

        int two_i_minus_1 = parent[cur][i - 1];
        parent.at(cur).at(i) = parent[(two_i_minus_1)][i - 1];
    }
    for (auto e : g[cur])
    {
        if (adj(cur, e) == par)
            continue;
        int w = adj(cur, e);
        parent_calc(w, cur);
        sub[cur] += sub[w];
    }
    out[cur] = (++tim);
}
/**
 * @brief literally what it says
 * 
 * @param u first node
 * @param v second node 
 * @return true when u is ancestor of v
 * @return false when u is not an ancestor of v
 */
bool is_first_anc_of_second(int u, int v)
{

    return in[u] <= in[v] && out[u] >= out[v];
}
/**
 * @brief finds the LCA using binary jumping in O(log2(N))
 * 
 * @param u a node
 * @param v another node
 * @return int the LCA of u and v
 */
int find_lca(int u, int v)
{
    if (is_first_anc_of_second(u, v))
        return u;

    if (is_first_anc_of_second(v, u))
        return v;

    for (int i = l; i >= 0; --i)
        if (!is_first_anc_of_second(parent[u][i], v))
            u = parent[u][i];
    return parent[u][0];
}
/**
 * @brief returns the distance between two nodes in the tree
 * 
 * @param u a node
 * @param v another node
 * @return int the distance between u and v (no. of edges)
 */
int d(int u, int v)
{
    return (level[u] + level[v] - 2 * level[find_lca(u, v)]);
}

/**
 * @brief a structure to store data 
 * 
 */
struct Data
{

    //use required attributes here mn stores the answer and is intialized with -inf because it is max queries
    int mn = -inf;

    //Default Values
    // since max queries are to be done (on positive numbers) default value of mn is aasigned 0,
    // but instead if min queries are to be done assign mn=INT_MAX.
    // for other cases give appropriate values

    /**
     * @brief Construct a new Data object with default value -inf f
     *      or max queries. Give appropriate values for other types of queries 
     * 
     */
    Data() : mn(-inf){};
};

struct SegTree
{
    // size of the base array
    int N;
    // segment tree
    vector<Data> st;
    // for lazy propagation
    vector<bool> cLazy;
    // value to be added
    vector<int> lazy;
    // base array a
    vector<int> a;
    void propagate(int node, int L, int R);
    void build(int node, int L, int R);
    void init(int n, vi a);
    void init(int n)
    {
        N = n;
        st.resize(4 * N + 5);
        cLazy.assign(4 * N + 5, false);
        lazy.assign(4 * N + 5, 0);
    }

    void merge(Data &cur, Data &l, Data &r);
    Data Query(int node, int L, int R, int i, int j)
    {
        if (cLazy[node])
            propagate(node, L, R);
        if (j < L || i > R)
            return Data();
        if (i <= L && R <= j)
            return st[node];
        int M = (L + R) / 2;
        Data left = Query(lc(node), L, M, i, j);
        Data right = Query(rc(node), M + 1, R, i, j);
        Data cur;
        merge(cur, left, right);
        return cur;
    }
    Data pQuery(int node, int L, int R, int pos)
    {
        if (cLazy[node])
            propagate(node, L, R);
        if (L == R)
            return st[node];
        int M = L + (R - L) / 2;
        if (pos <= M)
            return pQuery(lc(node), L, M, pos);
        else
            return pQuery(rc(node), M + 1, R, pos);
    }
    void Update(int node, int L, int R, int i, int j, int val)
    {
        if (cLazy[node])
            propagate(node, L, R);
        if (j < L || i > R)
            return;
        if (i <= L && R <= j)
        {
            cLazy[node] = 1;
            lazy[node] += val;
            propagate(node, L, R);
            return;
        }
        int M = L + (R - L) / 2;
        Update(lc(node), L, M, i, j, val);
        Update(rc(node), M + 1, R, i, j, val);
        merge(st[node], st[lc(node)], st[rc(node)]);
    }
    void pUpdate(int node, int L, int R, int pos, int val)
    {
        if (cLazy[node])
            propagate(node, L, R);
        if (L == R)
        {
            cLazy[node] = 1;
            lazy[node] = val;
            propagate(node, L, R);
            return;
        }
        int M = L + (R - L) / 2;
        if (pos <= M)
            pUpdate(lc(node), L, M, pos, val);
        else
            pUpdate(rc(node), M + 1, R, pos, val);
        merge(st[node], st[lc(node)], st[rc(node)]);
    }

    Data query(int pos);

    Data query(int l, int r);

    void update(int pos, int val);

    void update(int l, int r, int val);

} ST;

void SegTree::propagate(int node, int L, int R)
{
    if (lazy[node] == 0)
        return;
    st[node].mn += lazy[node];
    if (L != R)
    {
        cLazy[lc(node)] = 1;
        cLazy[rc(node)] = 1;
        lazy[lc(node)] += lazy[node];
        lazy[rc(node)] += lazy[node];
    }

    cLazy[node] = 0;
    lazy[node] = 0;
}

void SegTree::merge(Data &cur, Data &l, Data &r)
{
    cur.mn = max(l.mn, r.mn);
}
/**
     * @brief build the segment tree recursively starting from node 'node'
     * st[node] stores the info in the range [L,R] in the base array a
     * @param node the node which is to be built
     * @param L the left limit of the node
     * @param R  the right limit of the node
     */

void SegTree::build(int node, int L, int R)
{
    if (L == R)
    {
        st[node].mn = a[L];
        return;
    }
    int M = L + (R - L) / 2;
    build(lc(node), L, M);
    build(rc(node), M + 1, R);
    merge(st[node], st[lc(node)], st[rc(node)]);
}

void SegTree::init(int n, vi a)
{
    init(n);
    this->a = move(a);
    build(1, 1, N);
}

Data SegTree::query(int pos)
{
    return pQuery(1, 1, N, pos);
}

Data SegTree::query(int l, int r)
{
    return Query(1, 1, N, l, r);
}

void SegTree::update(int pos, int val)
{
    pUpdate(1, 1, N, pos, val);
}

void SegTree::update(int l, int r, int val)
{
    Update(1, 1, N, l, r, val);
}

int queryUp(int from, int to)
{
    int curr = from;
    int ans = 0;
    while (chainNo[curr] != chainNo[to])
    {
        if (pos[curr] == pos[chainHead[chainNo[curr]]])
            ans = max(ans, ST.query(pos[curr]).mn);
        else
            ans = max(ans, ST.query(pos[chainHead[chainNo[curr]]], pos[curr]).mn);
        curr = parent[chainHead[chainNo[curr]]][0];
    }
    ans = max(ans, ST.query(pos[to], pos[curr]).mn);

    return ans;
}

int path_query(int a, int b)
{
    return max(queryUp(a, find_lca(a, b)), queryUp(b, find_lca(a, b)));
}

void preprocess(int n)
{
    l = log2(n) + 2;
    parent.assign(n + 1, vi(2 + l, 0));

    in.resize(n + 1), out.resize(n + 1);
    parent_calc(1, 1);
    chainHead[nchain] = chainParent[nchain] = 1;
    HLD(1, 0);
    ST.init(blen - 1, vector<int>(baseArray, baseArray + blen));
}
endsnippet
